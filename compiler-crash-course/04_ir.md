# 中间表示

到目前为止，我们处理的都是某种树形结构——解析树、抽象语法树、带类型的抽象语法树。
但是，嵌套的树形结构表达式让代码操作起来还是太麻烦了。
有没有更简单的方式能表示代码的运算过程呢？

有的，兄弟，有的。它叫做 [中间代码][ir]（Intermediate Representation，简称 IR）。

[ir]: https://en.wikipedia.org/wiki/Intermediate_representation

## 中间代码的种类

中间代码本身并没有什么特殊性：
它和汇编/机器码一样，只是某种编译目标而已。
它和汇编/机器码的不同点在于，
相对于那些底层代码体积小、便于解码执行等特点，
中间代码通常保有更多来自源代码的信息和元信息，
而且被设计的便于程序去阅读、处理和修改。

一般来说，中间代码会从两个方面简化源代码的结构：

- 从控制流的角度，它一般会将原始程序中多变的控制流结构简化成几个基本的控制流单元。
  - 一种常见的抽象方式会将代码组织成 “基本块”，也就是中间不再有其他控制流操作（分支、跳入等）的代码块，
    在基本块的内部则是一串顺序执行的指令。
  - 另一种则会将所有控制流简化到只有条件、循环等少数几种基础结构，也便于分析和优化。
- 从数据的角度，它一般会简化表达式的结构，通常只允许单层的表达式存在；
  多层的表达式会借助中间变量被拆成多条简单的指令。

命令式语言和函数式语言常用的中间代码格式是不同的，
在我们的示例中都会用到。

我们用下面的简单程序作为例子演示不同的中间代码：

```
let mut x = 1 + 2 + 4
x = 5
let y = adder(x, 3)
if y > 10 {
    print_int(y)
} else {
    print_int(0)
}
```

## 命令式中间代码

[三地址码][3ac] (Three-address code, 3AC) 是一种常见的命令式中间代码形式。
它很类似一些 CPU 的汇编语言，
但是它的 “寄存器” （对于源代码来说类似于变量，在这里被称作操作数）数量可以是无限的。
三地址码一般使用基本块作为控制流的组织方式。

[3ac]: https://en.wikipedia.org/wiki/Three-address_code

```c
bb0:
    // let mut x = 1 + 2 + 4
    %temp0 = add 1, 2
    %x = add %temp0, 4
    // x = 5
    %x = 5
    // let y = adder(x, 3)
    %y = call %adder(%x, 3)
    // if y > 10:
    %condition = compare %y > 10
    if condition: goto bb1
    else: goto bb2
bb1:
    // print_int(y)
    call %print_int(%y)
    goto bb3
bb2:
    // print_int(0)
    call %print_int(0)
    goto bb3
bb3:
    // end
    return
```

可以看出，正如之前所说，这个中间代码的结构很像汇编语言。
对于这个简单的例子，如果我们为每一个变量都分配一个寄存器，
那么我们就可以将它一比一地翻译成汇编语言。

但是，如果你想在这种中间代码上进行一些简化操作
（比如去除所有无用的赋值操作，或者简化形如 `x - x` 的代码），
那你会遇到一些问题：
你没有一个很简单的方式来找到代码中某一位置的变量定义。
比如，要想知道 `call %adder(%x, 3)` 这一行中 `%x` 的值是从哪里来的，
你需要从当前位置向前搜索，直到找到对 `%x` 的最近一次赋值。

有没有方法来简化这个问题呢？当然是有的。
这个操作叫做 [静态单赋值形式][ssa] (Static Single Assignment, SSA)。

在 SSA 形式的中间代码中，每个变量必须被赋值一次，且只有一次。
这样，每个变量的定义位置就变得唯一，
我们就可以直接通过变量名找到它的定义位置，而不需要搜索了。

用 SSA 格式写出的上面的代码如下：

```c
bb0:
    // let mut x = 1 + 2 + 4
    %temp0 = add 1, 2
    %x0 = add %temp0, 4
    // x = 5
    %x1 = 5
    // let y = adder(x, 3)
    %y0 = call %adder(%x1, 3)
    // if y > 10:
    %condition0 = compare %y0 > 10
    if condition0: goto bb1
    else: goto bb2
bb1:
    // print_int(y)
    call %print_int(%y0)
    goto bb3
bb2:
    // print_int(0)
    call %print_int(0)
    goto bb3
bb3:
    // end
    return
```

我们可以清楚地看到，
`x` 的两次赋值被分配到了不同的变量名 `%x0` 和 `%x1` 上，
而 `call %adder` 中使用的是 `%x1`，也就是第二次赋值的结果。
`%x0` 其实是一个无用的变量，我们也可以很容易地发现它并将其删除。

当然，还有一个问题没有解决：
如果一个变量在多个控制流路径上被赋值了，
那么在控制流汇合的地方我们该用哪个变量呢？
SSA 的解决方案是引入一个新的操作，叫做 Phi。
Phi 的作用是根据上一个执行的控制流路径选择一个变量。

举个例子，比如：

```
if cond {
    x = 1
} else {
    x = 2
}
x
```

这段代码转换成 SSA 之后大概是这样：

```c
bb0:
    if cond: goto bb1
    else: goto bb2
bb1:
    %x1 = 1
    goto bb3
bb2:
    %x2 = 2
    goto bb3
bb3:
    // 如果上一个执行的是 bb1，就选择 %x1
    // 如果上一个执行的是 bb2，就选择 %x2
    %x3 = phi [(bb1, %x1), (bb2, %x2)]
```

因为 SSA 形式有很多的优点，
基本上所有现代优化编译器在（较为贴近机器的）中间代码阶段都会使用 SSA 形式。
一个很常见的例子是 [LLVM](https://llvm.org) 编译器框架使用的 [LLVM IR](https://llvm.org/docs/LangRef.html)。

在 MiniMoonBit 的编程比赛中，你也可以提交输出 LLVM IR 格式的代码的程序。

如果你想实现一个 SSA 形式的中间代码，你可以在 [MoonLLVM][] 的代码仓库中找到值得参考的部分。
如果你希望你的编译器输出 LLVM IR 格式的代码，
你也可以使用上面的 MoonLLVM 作为你的编译目标。

[moonllvm]: https://github.com/moonbitlang/MoonLLVM/blob/master/IR/IRBuilder.mbt

### 将表达式树转换为 SSA 格式的中间代码

对于所有变量都不可变的基于表达式的语言来说，
将表达式转换为 SSA 形式的中间代码的过程，
实际上就是一次后序遍历。
在转换每个节点之前，
先将子节点转换为中间代码，并获得它们对应的变量名，
然后用这些变量名作为参数将当前节点转换为中间代码，
最后把结果对应的变量名返回给再上一层。

用伪代码表示的话：

```py
def expr_to_ir(ctx: Context, expr: Expr) -> Value:
    match expr:
        case Variable(name):
            return ctx.lookup_variable(name)
        case IntLiteral(value):
            v = ctx.make_int(value)
            return v
        case Add(left, right):
            left_val = expr_to_ir(ctx, left)
            right_val = expr_to_ir(ctx, right)
            v = ctx.insert_add(left_val, right_val)
            return v
        case Let(name, value_expr, body_expr):
            value_val = expr_to_ir(ctx, value_expr)
            ctx.bind_variable(name, value_val)
            body_val = expr_to_ir(ctx, body_expr)
            ctx.unbind_variable(name)
            return body_val
```

对于可变变量的情况，你可以参考 [Braune et al. (2006)][braun] 提出的快速算法。
这篇论文将算法讲解得非常清楚，
我们在这里就不赘述了。

[braun]: https://doi.org/10.1007/978-3-642-37051-9_6

### 将表达式中的控制流转换为 SSA 格式的中间代码

考虑这样一个表达式：

```
(if y > 0 { foo() } else { bar() }) + 1
```

我们可以先把它像刚才一样拍扁成三地址码，但是保留其中 if 的部分：

```c
%cond = compare %y > 0
%if_result = if %cond { call foo() } else { call bar() }
%result = add %if_result, 1
```

我们可以看到，`%if_result` 这个变量其实很类似于在控制流的例子中，
在两边都赋值过的变量 `x`。
因此，我们可以把这个表达式看作：

```
let mut x   // uninitialized
if y > 0 {
    x = foo()
} else {
    x = bar()
}
x + 1
```

从而写出它对应的 SSA 格式：

```c
bb0:
    %cond0 = compare %y > 0
    if %cond0: goto bb1
    else: goto bb2
bb1:
    %x1 = call %foo()
    goto bb3
bb2:
    %x2 = call %bar()
    goto bb3
bb3:
    %x3 = phi [(bb1, %x1), (bb2, %x2)]
    %result = add %x3, 1
```

## 函数式中间代码

相比于命令式语言拥有可变的变量和赋值操作，
函数式语言更倾向于面向表达式进行运算。
因此，函数式的中间代码通常保留了表达式和基础的控制流结构，
整体以一个表达式树的形式存在。
但是，这个表达式树的结构相对于源代码来说会被大幅简化，
例如在函数式中也不存在嵌套的表达式。

一个常见的函数式中间代码被称作 K-标准型 (K-normal form, KNF)。
它保留了 `let` 绑定和函数调用等表达式，但是不允许嵌套的表达式存在。

> 你可能听说过 [ANF][]（A-normal form）这种形式。
> 它是一种比 KNF 格式稍微更严格一些的格式，但是两者的差别很小，
> 所以在这里我们不做区分。
> 如果你希望了解更多类似的信息，搜索 ANF 的资料会更多一些。

[anf]: https://en.wikipedia.org/wiki/A-normal_form

文章最开始的例子在 KNF 中大概可以表示如下：

```ocaml
let temp0: int = 1 + 2 in
    let temp1: int = temp0 + 4 in
        let x: ref[int] = ref(temp1) in
            let _: unit = set(x, 5) in
                let x_value: int = read(x) in
                    let y: int = adder(x, 3) in
                        if y > 10 then
                            print_int(y) : unit
                        else
                            print_int(0) : unit
```

其中，`let ... in` 和它之后的部分实际上是一整个表达式，
表示 `let` 定义的变量只在 `in` 之后的部分存在。

这种气功波式的嵌套结构看起来可能有点奇怪，
所以我们可以把它拍扁一点，变成更好看的形式（但是嵌套结构实际上没有改变）：

```ocaml
let temp0: int = 1 + 2 in
let temp1: int = temp0 + 4 in
let x: ref[int] = ref(temp1) in
let _: unit = set(x, 5) in
let x_value: int = read(x) in
let y: int = adder(x, 3) in
if y > 10 then
    print_int(y) : unit
else
    print_int(0) : unit
```

由于函数式语言中不存在可变变量，我们用一个堆上的内部可变量 `ref` 结构模拟一个可变变量。
`ref` 相关函数的定义类似于以下 C 语言代码：

```c
/// `ref` 内容的定义，其中 `Value` 类型代表你要存进去的数据类型
typedef struct { Value value; } RefStruct;
/// `ref` 本身是一个指向 `RefStruct` 的指针
typedef RefStruct* Ref;

/// 创建一个新的 `ref` 就是分配一块内存，并将值存进去
Ref ref(Value v) {
    Ref r = malloc(sizeof(RefStruct));
    r->value = v;
    return r;
}

/// 读取 `ref` 的值
Value read(Ref r) {
    return r->value;
}

/// 修改 `ref` 的值
void set(Ref r, Value v) {
    r->value = v;
}
```

一个 KNF 式的中间代码相对于 SSA 来说更好在 MoonBit 中声明一些。
例如，上面的例子可以通过如下方式声明：

```mbt
struct Variable { ... }

enum Knf {
    Value(KnfValue)
    Let(Variable, Knf, Knf)
}

enum KnfValue {
    IntLiteral(Int)
    Variable(String)
    Add(Variable, Variable)
    If(Variable, Knf, Knf)
}
```

可以注意到，在这里除了条件表达式之外，
KNF 式的中间代码不包含任何的嵌套表达式。
所有的中间结果都被拆成了单独的 `Let` 绑定，
和 SSA 形式的中间代码类似。

与 SSA 不同的是，在 KNF 中，
因为一切代码依然还是表达式，我们没有必要引入 Phi 操作，
而是直接保留了原先的控制流结构。

### 将表达式树转换为 KNF 格式

由于 KNF 依然是基于表达式的中间代码格式，
将表达式树转换为 KNF 会更简单一些。
我们依然使用伪代码表示一下：

```py
def expr_to_ir(ctx: Context, expr: Expr) -> Knf:
    match expr:
        case Variable(name):
            return ctx.lookup_variable(name)
        case IntLiteral(value):
            return Knf.Value(KnfValue.IntLiteral(value))
        case Add(left, right):
            # let _left = <left> in
            # let _right = <right> in
            # _left + _right
            left_var = ctx.new_var()
            left_result = expr_to_ir(ctx, left)
            right_var = ctx.new_var()
            right_result = expr_to_ir(ctx, right)

            return Knf.Let(left_var, left_result,
                Knf.Let(right_var, right_result,
                    Knf.Value(KnfValue.Add(left_var, right_var))))
        case Let(name, value_expr, body_expr):
            var = ctx.new_var(name)
            value_result = expr_to_ir(ctx, value_expr)
            body_expr = expr_to_ir(ctx, value_expr)
            return Knf.Let(var, value_result, body_expr)
```

注意到，其实这个函数会返回出形如这样的代码：

```ocaml
let a =
    let left = 1 in
    let right = 1 in
    left + right
in ...
```

这段代码等价于：

```ocaml
let left = 1 in
let right = 1 in
let a = left + right in
...
```

这是 ANF 和 KNF 的区别之一：ANF 只接受后一种代码，而 KNF 可以同时接受两者。
在实践中，我们一般会在优化中把前者转换到后者。
